<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Transit Hunter - Rastreador de Aviones y Sol</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS & JS (Mapas) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- SunCalc (Posición del Sol) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        #map { height: 100%; width: 100%; z-index: 0; }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Animación para alerta de tránsito */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .transit-alert {
            animation: pulse-red 2s infinite;
            border-color: #ef4444;
        }
        canvas { touch-action: none; }
        
        /* Spinner de carga */
        .loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #fbbf24;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-900 text-white h-screen overflow-hidden flex flex-col md:flex-row">

    <!-- Sidebar / Dashboard -->
    <div class="w-full md:w-96 glass-panel flex flex-col h-1/3 md:h-full z-20 border-r border-slate-700 shadow-2xl">
        <div class="p-4 border-b border-slate-700 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-amber-400 flex items-center gap-2">
                    <i data-lucide="sun"></i> Transit Hunter 
                    <span class="text-[10px] font-mono font-normal text-slate-400 bg-slate-800 border border-slate-700 px-1.5 rounded ml-1">v1.4.0</span>
                </h1>
                <p class="text-xs text-slate-400">Rastreador de Intersección Solar</p>
            </div>
            <div id="gps-status" class="text-xs px-2 py-1 rounded bg-red-900 text-red-200">No GPS</div>
        </div>

        <!-- Solar Data -->
        <div class="p-4 grid grid-cols-2 gap-2 text-sm border-b border-slate-700 bg-slate-800/50">
            <div>
                <span class="text-slate-400 block text-xs">Azimut Solar</span>
                <span id="sun-az" class="font-mono text-amber-200">--°</span>
            </div>
            <div>
                <span class="text-slate-400 block text-xs">Elevación Solar</span>
                <span id="sun-alt" class="font-mono text-amber-200">--°</span>
            </div>
        </div>

        <!-- Transit List -->
        <div class="flex-1 overflow-y-auto p-2">
            <h3 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2 px-2 flex justify-between items-center">
                <span>Próximos Tránsitos</span>
                <span id="data-indicator" class="text-[10px] text-slate-500 font-normal border border-slate-700 px-1 rounded">SIMULACIÓN</span>
            </h3>
            <div id="transit-list" class="space-y-2">
                <div class="text-center text-slate-500 py-4 italic text-sm">
                    Esperando datos...
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="p-4 border-t border-slate-700 bg-slate-900 space-y-3">
            <div class="flex items-center justify-between">
                <span class="text-sm font-semibold text-slate-300">Fuente de Datos</span>
                <div id="loading-spinner" class="loader opacity-0"></div>
            </div>
            
            <div class="flex bg-slate-800 rounded p-1">
                <button onclick="setMode('sim')" id="btn-sim" class="flex-1 text-xs py-1.5 px-2 rounded bg-slate-600 text-white font-medium transition-colors">Simulación</button>
                <button onclick="setMode('real')" id="btn-real" class="flex-1 text-xs py-1.5 px-2 rounded text-slate-400 hover:text-white transition-colors">OpenSky (Real)</button>
            </div>

            <p class="text-[10px] text-slate-500 leading-tight">
                <span class="text-amber-500 font-bold">Nota OpenSky:</span> Los datos reales tienen 10-20s de retraso. Si falla, el sistema volverá a simulación.
            </p>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 relative h-2/3 md:h-full flex flex-col">
        
        <!-- Sky View (Canvas) -->
        <div class="h-1/2 relative bg-gradient-to-b from-sky-900 to-sky-700 border-b border-slate-700 overflow-hidden group">
            <div class="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs z-10">Vista del Cielo (Cámara Virtual)</div>
            <canvas id="skyCanvas" class="w-full h-full object-cover"></canvas>
            
            <!-- Crosshair overlay -->
            <div class="absolute inset-0 pointer-events-none flex items-center justify-center opacity-30">
                <div class="w-full h-px bg-white/20 absolute"></div>
                <div class="h-full w-px bg-white/20 absolute"></div>
                <div class="w-20 h-20 border border-white/20 rounded-full absolute"></div>
            </div>
        </div>

        <!-- Map View -->
        <div class="h-1/2 relative">
            <div id="map"></div>
            <div class="absolute bottom-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded z-[1000] pointer-events-none">
                Línea Amarilla: Sol | Azul: Aviones
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION & STATE ---
        const STATE = {
            userLat: null,
            userLon: null,
            sunPos: { azimuth: 0, altitude: 0 },
            planes: [],
            mode: 'sim', // 'sim' or 'real'
            lastUpdate: Date.now(),
            lastApiFetch: 0
        };

        const SETTINGS = {
            viewRadiusKm: 200, 
            sunAngularSizeDeg: 0.53, 
            apiIntervalMs: 10000 // OpenSky rate limit for anon users is ~10s
        };

        // --- DOM ELEMENTS ---
        const els = {
            sunAz: document.getElementById('sun-az'),
            sunAlt: document.getElementById('sun-alt'),
            gpsStatus: document.getElementById('gps-status'),
            transitList: document.getElementById('transit-list'),
            skyCanvas: document.getElementById('skyCanvas'),
            dataIndicator: document.getElementById('data-indicator'),
            btnSim: document.getElementById('btn-sim'),
            btnReal: document.getElementById('btn-real'),
            spinner: document.getElementById('loading-spinner')
        };

        // --- INITIALIZATION ---
        lucide.createIcons();
        
        const map = L.map('map').setView([40.4168, -3.7038], 8);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap &copy; CARTO',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);

        const planeIcon = L.divIcon({
            className: 'custom-plane-icon',
            html: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(45deg); filter: drop-shadow(0 0 4px #38bdf8);"><path d="M2 12h20"/><path d="M13 2l9 10-9 10"/><path d="M2 12l5-5m-5 5l5 5"/></svg>`,
            iconSize: [24, 24],
            iconAnchor: [12, 12]
        });

        const layers = {
            user: L.layerGroup().addTo(map),
            sunLine: L.layerGroup().addTo(map),
            planes: L.layerGroup().addTo(map)
        };

        // --- MODE SWITCHING ---
        window.setMode = function(mode) {
            STATE.mode = mode;
            STATE.planes = []; // Clear current planes
            layers.planes.clearLayers();
            
            if (mode === 'sim') {
                els.btnSim.className = "flex-1 text-xs py-1.5 px-2 rounded bg-slate-600 text-white font-medium transition-colors";
                els.btnReal.className = "flex-1 text-xs py-1.5 px-2 rounded text-slate-400 hover:text-white transition-colors";
                els.dataIndicator.innerText = "SIMULACIÓN";
                els.dataIndicator.className = "text-[10px] text-slate-500 font-normal border border-slate-700 px-1 rounded bg-slate-800";
            } else {
                els.btnReal.className = "flex-1 text-xs py-1.5 px-2 rounded bg-emerald-700 text-white font-medium transition-colors";
                els.btnSim.className = "flex-1 text-xs py-1.5 px-2 rounded text-slate-400 hover:text-white transition-colors";
                els.dataIndicator.innerText = "OPENSKY NETWORK";
                els.dataIndicator.className = "text-[10px] text-emerald-300 font-normal border border-emerald-800 px-1 rounded bg-emerald-900/30";
                
                // Trigger immediate fetch
                if(STATE.userLat) fetchRealPlanes();
            }
        };

        // --- API INTEGRATION (OpenSky) ---
        async function fetchRealPlanes() {
            if (!STATE.userLat || STATE.mode !== 'real') return;
            
            const now = Date.now();
            if (now - STATE.lastApiFetch < SETTINGS.apiIntervalMs) return;

            els.spinner.style.opacity = '1';
            STATE.lastApiFetch = now;

            // Bounding box (approx 1 degree ~ 111km)
            const boxSize = 2.0; // Increased to 2 degrees for wider range
            const lamin = STATE.userLat - boxSize;
            const lamax = STATE.userLat + boxSize;
            const lomin = STATE.userLon - boxSize;
            const lomax = STATE.userLon + boxSize;

            const url = `https://opensky-network.org/api/states/all?lamin=${lamin}&lomin=${lomin}&lamax=${lamax}&lomax=${lomax}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('API Limit or Error');
                
                const data = await response.json();
                els.spinner.style.opacity = '0';

                if (!data.states) return;

                STATE.planes = data.states
                    .filter(s => !s[8] && s[6] && s[5]) // Must not be on ground, must have coords
                    .map(s => {
                        const altFt = (s[7] || 0) * 3.28084;
                        const spdKts = (s[9] || 0) * 1.94384;
                        const callsign = s[1].trim() || s[0]; // Callsign or ICAO
                        return new Plane(s[0], s[6], s[5], s[10] || 0, spdKts, altFt, callsign);
                    });

                updatePlaneMarkers();

            } catch (err) {
                console.warn("OpenSky fetch failed", err);
                els.spinner.style.opacity = '0';
                
                const errDiv = document.createElement('div');
                errDiv.className = "fixed top-4 right-4 bg-red-900 text-white p-2 rounded text-xs z-50 shadow-lg";
                errDiv.innerText = "Error obteniendo datos reales. Volviendo a Simulación.";
                document.body.appendChild(errDiv);
                setTimeout(() => errDiv.remove(), 3000);
                
                setMode('sim');
            }
        }

        // --- GEOLOCATION & SUN CALC ---
        function updateSunPosition() {
            if (!STATE.userLat) return;
            const now = new Date();
            const sun = SunCalc.getPosition(now, STATE.userLat, STATE.userLon);
            STATE.sunPos = sun; 

            const azDeg = (sun.azimuth * (180/Math.PI) + 180) % 360;
            const altDeg = sun.altitude * (180/Math.PI);

            els.sunAz.innerText = azDeg.toFixed(1) + '°';
            els.sunAlt.innerText = altDeg.toFixed(1) + '°';

            layers.sunLine.clearLayers();
            const lineLen = 100000; // meters
            const endLat = STATE.userLat + (lineLen/111111) * Math.cos(sun.azimuth + Math.PI); 
            
            const line = [
                [STATE.userLat, STATE.userLon],
                [endLat, STATE.userLon + (lineLen/111111) * Math.sin(sun.azimuth + Math.PI) / Math.cos(STATE.userLat * Math.PI/180)]
            ];
        }

        function initLocation() {
            if (navigator.geolocation) {
                els.gpsStatus.innerText = "Localizando...";
                els.gpsStatus.className = "text-xs px-2 py-1 rounded bg-yellow-900 text-yellow-200";
                
                navigator.geolocation.watchPosition((pos) => {
                    STATE.userLat = pos.coords.latitude;
                    STATE.userLon = pos.coords.longitude;
                    
                    els.gpsStatus.innerText = "GPS Activo";
                    els.gpsStatus.className = "text-xs px-2 py-1 rounded bg-emerald-900 text-emerald-200";

                    layers.user.clearLayers();
                    L.marker([STATE.userLat, STATE.userLon]).addTo(layers.user)
                        .bindPopup("Tu Ubicación").openPopup();
                    map.setView([STATE.userLat, STATE.userLon]);
                    
                    updateSunPosition();
                    if(STATE.mode === 'real') fetchRealPlanes();

                }, (err) => {
                    els.gpsStatus.innerText = "Error GPS";
                });
            } else {
                alert("Geolocalización no soportada.");
            }
        }

        // --- CLASS & UTILS ---
        class Plane {
            constructor(id, lat, lon, heading, speedKnots, altitudeFt, callsign) {
                this.id = id;
                this.lat = lat;
                this.lon = lon;
                this.heading = heading; 
                this.speed = speedKnots; 
                this.altitude = altitudeFt;
                this.callsign = callsign || id;
                this.marker = null;
            }
            
            // Calculate future position (Simulated physics step)
            projectPosition(dtSeconds) {
                const R = 6371; 
                const distKm = (this.speed * 1.852) * (dtSeconds / 3600);
                const brng = this.heading * Math.PI / 180;
                const lat1 = this.lat * Math.PI / 180;
                const lon1 = this.lon * Math.PI / 180;
                
                let lat2 = Math.asin( Math.sin(lat1)*Math.cos(distKm/R) + Math.cos(lat1)*Math.sin(distKm/R)*Math.cos(brng) );
                let lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(distKm/R)*Math.cos(lat1), Math.cos(distKm/R)-Math.sin(lat1)*Math.sin(lat2));
                
                return { lat: lat2 * 180 / Math.PI, lon: lon2 * 180 / Math.PI };
            }

            moveSimulated(dt) {
                const next = this.projectPosition(dt);
                this.lat = next.lat;
                this.lon = next.lon;
            }
        }

        function spawnSimPlane(forceTransit = false) {
            if (!STATE.userLat) return;
            const id = Math.random().toString(36).substr(2, 5);
            let lat, lon, heading, alt;
            
            const sunAzDeg = (STATE.sunPos.azimuth * (180/Math.PI) + 180) % 360;

            if (forceTransit) {
                // SPAWN FURTHER AWAY for earlier warning
                const spawnDist = 1.0; // ~111km away (Increased from 0.3)
                const spawnAngle = sunAzDeg - 35; 
                lat = STATE.userLat + (spawnDist * Math.cos(spawnAngle * Math.PI / 180));
                lon = STATE.userLon + (spawnDist * Math.sin(spawnAngle * Math.PI / 180));
                heading = (sunAzDeg + 90) % 360;
                alt = 30000;
            } else {
                lat = STATE.userLat + (Math.random() - 0.5) * 1.5; // Wider spawn area
                lon = STATE.userLon + (Math.random() - 0.5) * 1.5;
                heading = Math.random() * 360;
                alt = 10000 + Math.random() * 30000;
            }
            
            const airlines = ['IBE', 'RYR', 'VLG', 'AEA', 'Lufthansa'];
            const callsign = airlines[Math.floor(Math.random()*airlines.length)] + Math.floor(Math.random()*9000);
            
            STATE.planes.push(new Plane(id, lat, lon, heading, 300 + Math.random()*200, alt, callsign));
        }

        function calculateLookAngles(userLat, userLon, planeLat, planeLon, planeAltFt) {
            const R = 6371e3; 
            const dLat = (planeLat - userLat) * Math.PI / 180;
            const dLon = (planeLon - userLon) * Math.PI / 180;
            const lat1 = userLat * Math.PI / 180;
            const lat2 = planeLat * Math.PI / 180;

            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const surfaceDist = R * c;

            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let az = Math.atan2(y, x);
            let bearingDeg = (az * 180 / Math.PI + 360) % 360;

            const elevationRad = Math.atan2(planeAltFt * 0.3048, surfaceDist);
            const elevationDeg = elevationRad * 180 / Math.PI;

            return { az: bearingDeg, alt: elevationDeg, dist: surfaceDist };
        }
        
        // --- PREDICTION LOGIC ---
        function predictTransit(plane, userLat, userLon, sunAzDeg, sunAltDeg) {
            // 1. Current State
            const lookNow = calculateLookAngles(userLat, userLon, plane.lat, plane.lon, plane.altitude);
            
            // 2. Future State (1 second later)
            const futurePos = plane.projectPosition(1); 
            const lookFuture = calculateLookAngles(userLat, userLon, futurePos.lat, futurePos.lon, plane.altitude);
            
            // 3. Angular Velocity (deg/s)
            let dAz = lookFuture.az - lookNow.az;
            if (dAz > 180) dAz -= 360; // Handle wrapping
            if (dAz < -180) dAz += 360;
            
            const dAlt = lookFuture.alt - lookNow.alt;
            
            // 4. Relative Position to Sun (degrees)
            let relAz = lookNow.az - sunAzDeg;
            if (relAz > 180) relAz -= 360;
            if (relAz < -180) relAz += 360;
            
            const relAlt = lookNow.alt - sunAltDeg;
            
            // 5. Projection to Cartesian plane for CPA (Closest Point of Approach)
            // x = Azimuth diff (corrected for elevation), y = Altitude diff
            // Correction: dx = dAz * cos(SunElevation)
            const cosAlt = Math.cos(sunAltDeg * Math.PI / 180);
            
            const px = relAz * cosAlt;
            const py = relAlt;
            
            const vx = dAz * cosAlt;
            const vy = dAlt;
            
            // 6. Solve for time t where distance is minimized
            // dist^2 = (px + vx*t)^2 + (py + vy*t)^2
            // Derivative = 0 => t = -(px*vx + py*vy) / (vx^2 + vy^2)
            
            const v2 = vx*vx + vy*vy;
            if (v2 < 0.000001) return null; // Not moving significantly
            
            const t_cpa = -(px*vx + py*vy) / v2;
            
            if (t_cpa < 0) return null; // Closest point was in the past
            
            // 7. Calculate distance at CPA
            const cpaX = px + vx * t_cpa;
            const cpaY = py + vy * t_cpa;
            const distAtCpa = Math.sqrt(cpaX*cpaX + cpaY*cpaY);
            
            return {
                seconds: t_cpa,
                minDist: distAtCpa
            };
        }

        function updatePlaneMarkers() {
            const activeIds = new Set(STATE.planes.map(p => p.id));
            layers.planes.eachLayer(layer => {
                if (!activeIds.has(layer.options.planeId)) {
                    layers.planes.removeLayer(layer);
                }
            });

            STATE.planes.forEach(p => {
                if (!p.marker) {
                    p.marker = L.marker([p.lat, p.lon], {
                        icon: planeIcon,
                        planeId: p.id 
                    }).addTo(layers.planes);
                    p.marker.bindPopup(`<b>${p.callsign}</b><br>Alt: ${Math.round(p.altitude)}ft<br>Spd: ${Math.round(p.speed)}kts`);
                } else {
                    p.marker.setLatLng([p.lat, p.lon]);
                    const el = p.marker.getElement().querySelector('svg');
                    if(el) el.style.transform = `rotate(${p.heading - 45}deg)`;
                }
            });
        }

        // --- MAIN LOOP ---
        function updateLoop() {
            const now = Date.now();
            const dt = (now - STATE.lastUpdate) / 1000;
            STATE.lastUpdate = now;

            updateSunPosition();

            if (STATE.mode === 'sim') {
                if (STATE.planes.length < 5 && STATE.userLat) {
                    if (Math.random() > 0.7) spawnSimPlane(true);
                    else spawnSimPlane(false);
                }
                STATE.planes.forEach(p => p.moveSimulated(dt));
                STATE.planes = STATE.planes.filter(p => {
                    const dist = Math.abs(p.lat - STATE.userLat) + Math.abs(p.lon - STATE.userLon);
                    if (dist > 2.0) { // Keep alive longer
                        if (p.marker) layers.planes.removeLayer(p.marker);
                        return false;
                    }
                    return true;
                });
                updatePlaneMarkers(); 
            } else {
                fetchRealPlanes();
            }

            const sunAzDeg = (STATE.sunPos.azimuth * (180/Math.PI) + 180) % 360;
            const sunAltDeg = STATE.sunPos.altitude * 180 / Math.PI;
            const sunRad = SETTINGS.sunAngularSizeDeg / 2;
            const transits = [];

            STATE.planes.forEach(p => {
                if (!STATE.userLat) return;
                
                const look = calculateLookAngles(STATE.userLat, STATE.userLon, p.lat, p.lon, p.altitude);
                p.look = look;

                const azDiff = Math.abs(look.az - sunAzDeg);
                const azDist = Math.min(azDiff, 360 - azDiff);
                const altDiff = Math.abs(look.alt - sunAltDeg);
                const totalAngDist = Math.sqrt(azDist*azDist + altDiff*altDiff);

                if (totalAngDist < 45) { // Increased detection range to 45 deg
                    // Calculate Prediction
                    const prediction = predictTransit(p, STATE.userLat, STATE.userLon, sunAzDeg, sunAltDeg);
                    
                    transits.push({ 
                        plane: p, 
                        dist: totalAngDist,
                        isTransitNow: totalAngDist < sunRad,
                        prediction: prediction
                    });
                }
            });

            renderTransitList(transits, sunRad);
            drawSkyView(sunAzDeg, sunAltDeg, STATE.planes);

            requestAnimationFrame(updateLoop);
        }

        function renderTransitList(transits, sunRadius) {
            els.transitList.innerHTML = '';
            if (transits.length === 0) {
                els.transitList.innerHTML = `<div class="text-center text-slate-600 text-xs py-4">Sin tráfico cerca del sol</div>`;
                return;
            }
            transits.sort((a, b) => a.dist - b.dist);
            
            transits.forEach(t => {
                const isTransitNow = t.isTransitNow;
                const pred = t.prediction;
                // Will it transit in future? (Min Dist < Sun Radius and time > 0)
                const willTransit = pred && pred.minDist < sunRadius && pred.seconds > 0;
                
                let colorClass = 'bg-slate-800 border-slate-600';
                let status = `Dist: ${t.dist.toFixed(2)}°`;
                let timeText = '';

                if (isTransitNow) {
                    colorClass = 'bg-red-900/50 border-red-500 transit-alert';
                    status = '¡CRUZANDO AHORA!';
                } else if (willTransit) {
                    colorClass = 'bg-amber-900/40 border-amber-500';
                    status = 'TRÁNSITO PREVISTO';
                    // Calculate absolute time
                    const transitTime = new Date(Date.now() + pred.seconds * 1000);
                    const timeStr = transitTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    
                    // Color code based on time
                    let timeColor = "text-amber-200";
                    if(pred.seconds < 30) timeColor = "text-red-300 font-bold";
                    
                    timeText = `<div class="mt-1 flex justify-between items-center">
                        <span class="${timeColor}">T-${pred.seconds.toFixed(0)}s</span>
                        <span class="text-xs text-amber-100/70">a las ${timeStr}</span>
                    </div>`;
                } else {
                    // Just passing by
                    if (pred && pred.seconds > 0 && pred.seconds < 120) {
                         status = `Cruce a: ${pred.minDist.toFixed(2)}° en ${pred.seconds.toFixed(0)}s`;
                    }
                }
                
                const card = document.createElement('div');
                card.className = `p-2 rounded border ${colorClass} text-xs transition-all`;
                card.innerHTML = `
                    <div class="flex justify-between font-bold text-slate-200">
                        <span>${t.plane.callsign}</span>
                        <span>${Math.round(t.plane.altitude)}ft</span>
                    </div>
                    <div class="text-slate-400 mt-1">${status}</div>
                    ${timeText}
                `;
                els.transitList.appendChild(card);
            });
        }

        function drawSkyView(sunAz, sunAlt, planes) {
            const cvs = els.skyCanvas;
            const ctx = cvs.getContext('2d');
            
            // Resize logic
            const rect = cvs.getBoundingClientRect();
            if (cvs.width !== rect.width || cvs.height !== rect.height) {
                cvs.width = rect.width;
                cvs.height = rect.height;
            }

            const cx = cvs.width / 2;
            const cy = cvs.height / 2;
            const fov = 15; 
            const pxPerDeg = cvs.width / fov;

            // Background
            const grad = ctx.createLinearGradient(0, 0, 0, cvs.height);
            grad.addColorStop(0, '#0c4a6e'); 
            grad.addColorStop(1, '#0369a1'); 
            ctx.fillStyle = grad;
            ctx.fillRect(0,0, cvs.width, cvs.height);

            // Sun
            const sunRadiusPx = (SETTINGS.sunAngularSizeDeg / 2) * pxPerDeg;
            ctx.beginPath();
            ctx.arc(cx, cy, sunRadiusPx, 0, Math.PI * 2);
            ctx.fillStyle = '#fbbf24'; 
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#fbbf24';
            ctx.fill();
            ctx.shadowBlur = 0;

            // Crosshair
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(cvs.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, cvs.height);
            ctx.stroke();

            // Planes
            planes.forEach(p => {
                if (!p.look) return;

                let dAz = p.look.az - sunAz;
                if (dAz > 180) dAz -= 360;
                if (dAz < -180) dAz += 360;
                const dAlt = p.look.alt - sunAlt;

                const dx = dAz * pxPerDeg;
                const dy = -(dAlt * pxPerDeg); 

                // Draw Plane if visible within reasonable bounds (expanded for lines)
                if (Math.abs(dx) < cvs.width + 100 && Math.abs(dy) < cvs.height + 100) {
                    
                    // --- TRAJECTORY LINE (2 min prediction) ---
                    // Draw this BEFORE translating context for the plane icon
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(56, 189, 248, 0.5)'; // Light Blue, transparent
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]); // Dashed line

                    const startX = cx + dx;
                    const startY = cy + dy;
                    ctx.moveTo(startX, startY);

                    // Predict next 120 seconds in 10s steps
                    for(let t=10; t<=120; t+=10) { 
                         // Use physics projection
                         let futurePos = p.projectPosition(t);
                         // Recalculate look angles for that future position
                         let futureLook = calculateLookAngles(STATE.userLat, STATE.userLon, futurePos.lat, futurePos.lon, p.altitude);
                         
                         let fdAz = futureLook.az - sunAz;
                         if (fdAz > 180) fdAz -= 360;
                         if (fdAz < -180) fdAz += 360;
                         let fdAlt = futureLook.alt - sunAlt;
                         
                         let fdx = fdAz * pxPerDeg;
                         let fdy = -(fdAlt * pxPerDeg);
                         
                         ctx.lineTo(cx + fdx, cy + fdy);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset dash

                    // --- DRAW PLANE ICON ---
                    ctx.save();
                    ctx.translate(cx + dx, cy + dy);
                    
                    // Draw Plane as DOT
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2); // 3px dot
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    
                    // Small directional tick (heading relative to sun)
                    // Visual fix: If trajectory line is drawn, this tick is redundant but keeps style consistency
                    // Let's keep it but make it very subtle or remove it if line exists.
                    // The line is better. Let's just keep the dot + text.
                    
                    // Text Label
                    // Position label away from the trajectory line if possible, or just below
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(p.callsign, 5, -5);
                    
                    ctx.restore();
                }
            });
        }

        // Start
        initLocation();
        requestAnimationFrame(updateLoop);

    </script>
</body>
</html>